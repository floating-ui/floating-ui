{"version":3,"file":null,"sources":["../src/popper/polyfills/objectAssign.js","../src/popper/polyfills/requestAnimationFrame.js","../src/popper/utils/findIndex.js","../src/popper/utils/getOffsetParent.js","../src/popper/utils/getStyleComputedProperty.js","../src/popper/utils/getParentNode.js","../src/popper/utils/getScrollParent.js","../src/popper/utils/getOffsetRect.js","../src/popper/utils/isFixed.js","../src/popper/utils/getPosition.js","../src/popper/utils/getBoundingClientRect.js","../src/popper/utils/getScroll.js","../src/popper/utils/getOffsetRectRelativeToCustomParent.js","../src/popper/utils/getTotalScroll.js","../src/popper/utils/getBoundaries.js","../src/popper/utils/getOuterSizes.js","../src/popper/utils/getPopperClientRect.js","../src/popper/utils/getSupportedPropertyName.js","../src/popper/utils/isFunction.js","../src/popper/utils/isModifierRequired.js","../src/popper/utils/isNumeric.js","../src/popper/utils/isTransformed.js","../src/popper/utils/runModifiers.js","../src/popper/utils/setStyles.js","../src/popper/utils/index.js","../src/popper/utils/isNative.js","../src/popper/utils/debounce.js","../src/popper/utils/getOffsets.js","../src/popper/utils/setupEventListeners.js","../src/popper/utils/removeEventListeners.js","../src/popper/utils/sortModifiers.js","../src/popper/utils/isModifierEnabled.js","../src/popper/utils/setAttributes.js","../src/popper/modifiers/applyStyle.js","../src/popper/modifiers/arrow.js","../src/popper/utils/getOppositePlacement.js","../src/popper/utils/getOppositeVariation.js","../src/popper/modifiers/flip.js","../src/popper/modifiers/keepTogether.js","../src/popper/modifiers/offset.js","../src/popper/modifiers/preventOverflow.js","../src/popper/modifiers/shift.js","../src/popper/modifiers/hide.js","../src/popper/modifiers/index.js","../src/popper/index.js"],"sourcesContent":["/**\n * The Object.assign() method is used to copy the values of all enumerable own properties from one or more source\n * objects to a target object. It will return the target object.\n * This polyfill doesn't support symbol properties, since ES5 doesn't have symbols anyway\n * Source: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n * @function\n * @ignore\n */\nif (!Object.assign) {\n    Object.defineProperty(Object, 'assign', {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function(target) {\n            if (target === undefined || target === null) {\n                throw new TypeError('Cannot convert first argument to object');\n            }\n\n            var to = Object(target);\n            for (var i = 1; i < arguments.length; i++) {\n                var nextSource = arguments[i];\n                if (nextSource === undefined || nextSource === null) {\n                    continue;\n                }\n                nextSource = Object(nextSource);\n\n                var keysArray = Object.keys(nextSource);\n                for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\n                    var nextKey = keysArray[nextIndex];\n                    var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n                    if (desc !== undefined && desc.enumerable) {\n                        to[nextKey] = nextSource[nextKey];\n                    }\n                }\n            }\n            return to;\n        }\n    });\n}\n","/**\n * Polyfill for requestAnimationFrame\n * @function\n * @ignore\n */\nif (!window.requestAnimationFrame) {\n    var lastTime = 0;\n    var vendors = ['ms', 'moz', 'webkit', 'o'];\n    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\n        window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];\n    }\n\n    if (!window.requestAnimationFrame) {\n        window.requestAnimationFrame = function(callback) {\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = window.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);\n            lastTime = currTime + timeToCall;\n            return id;\n        };\n    }\n\n    if (!window.cancelAnimationFrame) {\n        window.cancelAnimationFrame = function(id) {\n            clearTimeout(id);\n        };\n    }\n}\n","/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nexport default function findIndex(arr, prop, value) {\n    // use filter instead of find because find has less cross-browser support\n    const match = arr.filter((obj) => (obj[prop] === value))[0];\n    return arr.indexOf(match);\n}\n","/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nexport default function getOffsetParent(element) {\n    // NOTE: 1 DOM access here\n    const offsetParent = element.offsetParent;\n    return !offsetParent || offsetParent.nodeName === 'BODY' ? window.document.documentElement : offsetParent;\n}\n","/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nexport default function getStyleComputedProperty(element, property) {\n    if (element.nodeType !== 1) {\n        return [];\n    }\n    // NOTE: 1 DOM access here\n    const css = window.getComputedStyle(element, null);\n    return css[property];\n}\n","/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nexport default function getParentNode(element) {\n    const parentNode = element.parentNode || element.host;\n    return (parentNode === window.document) ? window.document.documentElement : parentNode;\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\nimport getParentNode from './getParentNode';\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nexport default function getScrollParent(element) {\n    // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n    if (\n        element === window.document.scrollingElement ||\n        element === window.document.documentElement ||\n        element === window.document.body\n    ) {\n        return window.document.body;\n    }\n\n    // Firefox want us to check `-x` and `-y` variations as well\n    if (\n        ['scroll', 'auto'].indexOf(getStyleComputedProperty(element, 'overflow')) !== -1 ||\n        ['scroll', 'auto'].indexOf(getStyleComputedProperty(element, 'overflow-x')) !== -1 ||\n        ['scroll', 'auto'].indexOf(getStyleComputedProperty(element, 'overflow-y')) !== -1\n    ) {\n        return element;\n    }\n\n    return getScrollParent(getParentNode(element));\n}\n","/**\n * Get the position of the given element, relative to its offset parent\n * @method\n * @memberof Popper.Utils\n * @param {Element} element\n * @return {Object} position - Coordinates of the element and its `scrollTop`\n */\nexport default function getOffsetRect(element) {\n    const html = window.document.documentElement;\n\n    let elementRect;\n    if (element === html) {\n        elementRect = {\n            width: Math.max(html.clientWidth, window.innerWidth || 0),\n            height: Math.max(html.clientHeight, window.innerHeight || 0),\n            left: 0,\n            top: 0,\n        };\n    }\n    else {\n        elementRect = {\n            width: element.offsetWidth,\n            height: element.offsetHeight,\n            left: element.offsetLeft,\n            top: element.offsetTop,\n        };\n    }\n\n    elementRect.right = elementRect.left + elementRect.width;\n    elementRect.bottom = elementRect.top + elementRect.height;\n\n    // position\n    return elementRect;\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\nimport getParentNode from './getParentNode';\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nexport default function isFixed(element) {\n    if (element === window.document.body || element === window.document.documentElement) {\n        return false;\n    }\n    if (getStyleComputedProperty(element, 'position') === 'fixed') {\n        return true;\n    }\n    return isFixed(getParentNode(element));\n}\n","import getOffsetParent from './getOffsetParent';\nimport isFixed from './isFixed';\n\n/**\n * Helper used to get the position which will be applied to the popper\n * @method\n * @memberof Popper.Utils\n * @param config {HTMLElement} popper element\n * @returns {HTMLElement} reference element\n */\nexport default function getPosition(element) {\n    const container = getOffsetParent(element);\n\n    // Decide if the popper will be fixed\n    // If the reference element is inside a fixed context, the popper will be fixed as well to allow them to scroll together\n    const isParentFixed = isFixed(container);\n    return isParentFixed ? 'fixed' : 'absolute';\n}\n","/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nexport default function getBoundingClientRect(element) {\n    let rect;\n\n    // IE10 FIX: `getBoundingClientRect`, when executed on `documentElement`\n    // will not take in account the `scrollTop` and `scrollLeft`,\n    // use `body` instead to avoid these problems (only in IE10!)\n    if (element === window.document.documentElement && navigator.appVersion.indexOf('MSIE 10') !== -1) {\n        rect = window.document.body.getBoundingClientRect();\n    } else {\n        rect = element.getBoundingClientRect();\n    }\n\n    // subtract scrollbar size from sizes\n    const horizScrollbar = element.offsetWidth - element.clientWidth;\n    const vertScrollbar = element.offsetHeight - element.clientHeight;\n\n    return {\n        left: rect.left,\n        top: rect.top,\n        right: rect.right - horizScrollbar,\n        bottom: rect.bottom - vertScrollbar,\n        width: rect.right - rect.left - horizScrollbar,\n        height: rect.bottom - rect.top - vertScrollbar,\n    };\n}\n","export default function getScroll(element, side = 'top') {\n    const body = window.document.body;\n    const html = window.document.documentElement;\n    const scrollingElement = window.document.scrollingElement || html;\n\n    const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n    if (element === body || element === html) {\n        return scrollingElement[upperSide];\n    }\n    return element[upperSide];\n}\n","import getBoundingClientRect from './getBoundingClientRect';\nimport getScrollParent from './getScrollParent';\nimport getScroll from './getScroll';\nimport getOffsetParent from './getOffsetParent';\n\n/**\n * Given an element and one of its parents, return the offset\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @param {HTMLElement} parent\n * @return {Object} rect\n */\nexport default function getOffsetRectRelativeToCustomParent(element, parent, fixed = false, transformed = false) {\n    const offsetParent = getOffsetParent(element);\n    const scrollParent = getScrollParent(parent);\n    const elementRect = getBoundingClientRect(element);\n    const parentRect = getBoundingClientRect(parent);\n\n    const rect = {\n        top: elementRect.top - parentRect.top,\n        left: elementRect.left - parentRect.left,\n        bottom: (elementRect.top - parentRect.top) + elementRect.height,\n        right: (elementRect.left - parentRect.left) + elementRect.width,\n        width: elementRect.width,\n        height: elementRect.height,\n    };\n\n    if (fixed && !transformed) {\n        const scrollTop = getScroll(scrollParent, 'top');\n        const scrollLeft = getScroll(scrollParent, 'left');\n        rect.top -= scrollTop;\n        rect.bottom -= scrollTop;\n        rect.left -= scrollLeft;\n        rect.right -= scrollLeft;\n    } else if (offsetParent.contains(scrollParent)) {\n        const scrollTop = getScroll(parent, 'top');\n        const scrollLeft = getScroll(parent, 'left');\n        rect.top += scrollTop;\n        rect.bottom += scrollTop;\n        rect.left += scrollLeft;\n        rect.right += scrollLeft;\n    }\n\n    return rect;\n}\n","import getScrollParent from './getScrollParent';\nimport getScroll from './getScroll';\nimport getParentNode from './getParentNode';\n\nexport default function getTotalScroll(element, side = 'top') {\n    const body = window.document.body;\n    const html = window.document.documentElement;\n\n    const scrollParent = getScrollParent(element);\n    const scroll = getScroll(scrollParent, side);\n\n    if (scrollParent !== body && scrollParent !== html) {\n        return scroll + getTotalScroll(getParentNode(scrollParent), side);\n    }\n    return scroll;\n}\n","import getOffsetParent from './getOffsetParent';\nimport getScrollParent from './getScrollParent';\nimport getOffsetRect from './getOffsetRect';\nimport getPosition from './getPosition';\nimport getOffsetRectRelativeToCustomParent from './getOffsetRectRelativeToCustomParent';\nimport getTotalScroll from './getTotalScroll';\nimport isFixed from './isFixed';\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {Object} data - Object containing the property \"offsets\" generated by `_getOffsets`\n * @param {Number} padding - Boundaries padding\n * @param {Element} boundariesElement - Element used to define the boundaries\n * @returns {Object} Coordinates of the boundaries\n */\nexport default function getBoundaries(popper, padding, boundariesElement) {\n    // NOTE: 1 DOM access here\n    let boundaries = {};\n    const offsetParent = getOffsetParent(popper);\n    const scrollParent = getScrollParent(popper);\n    const body = window.document.body;\n    const html = window.document.documentElement;\n\n    if (boundariesElement === 'window') {\n        // WINDOW\n        const height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);\n        const width = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);\n\n        boundaries = {\n            top: 0,\n            right: width,\n            bottom: height,\n            left: 0\n        };\n    } else if (boundariesElement === 'viewport') {\n        // VIEWPORT\n        const offsetParentRect = getOffsetRect(offsetParent);\n        const position = getPosition(popper);\n\n        if (position === 'fixed') {\n            boundaries = {\n                top: 0,\n                right: window.document.documentElement.clientWidth,\n                bottom: window.document.documentElement.clientHeight,\n                left: 0,\n            }\n        } else {\n            boundaries = {\n                top: 0 - offsetParentRect.top,\n                right: window.document.documentElement.clientWidth - offsetParentRect.left,\n                bottom: window.document.documentElement.clientHeight - offsetParentRect.top,\n                left: 0 - offsetParentRect.left\n            };\n        }\n    } else if (boundariesElement === 'scrollParent' || scrollParent === boundariesElement) {\n        // SCROLL PARENT IS BOUNDARIES ELEMENT\n        boundaries = getOffsetRectRelativeToCustomParent(scrollParent, offsetParent, isFixed(popper));\n    } else {\n        // BOUNDARIES ELEMENT\n        boundaries = getOffsetRectRelativeToCustomParent(boundariesElement, offsetParent, isFixed(popper));\n    }\n\n    const scrollLeft = getTotalScroll(popper, 'left');\n    const scrollTop = getTotalScroll(popper, 'top');\n    boundaries.right += scrollLeft;\n    boundaries.bottom += scrollTop;\n\n    // Add paddings\n    boundaries.left += padding;\n    boundaries.top += padding;\n    boundaries.right -= padding;\n    boundaries.bottom -= padding;\n\n    return boundaries;\n}\n","/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nexport default function getOuterSizes(element) {\n    // NOTE: 1 DOM access here\n    const display = element.style.display;\n    const visibility = element.style.visibility;\n\n    element.style.display = 'block';\n    element.style.visibility = 'hidden';\n\n    // original method\n    const styles = window.getComputedStyle(element);\n    const x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n    const y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n    const result = {\n        width: element.offsetWidth + y,\n        height: element.offsetHeight + x\n    };\n\n    // reset element styles\n    element.style.display = display;\n    element.style.visibility = visibility;\n\n    return result;\n}\n","/**\n * Given the popper offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} popperOffsets\n * @returns {Object} ClientRect like output\n */\nexport default function getPopperClientRect(popperOffsets) {\n    return Object.assign({}, popperOffsets,\n        {\n            right: popperOffsets.left + popperOffsets.width,\n            bottom: popperOffsets.top + popperOffsets.height\n        }\n    );\n}\n","/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase)\n */\nexport default function getSupportedPropertyName(property) {\n    const prefixes = ['', 'ms', 'webkit', 'moz', 'o'];\n\n    for (let i = 0; i < prefixes.length; i++) {\n        const toCheck = prefixes[i] ? prefixes[i] + property.charAt(0).toUpperCase() + property.slice(1) : property;\n        if (typeof window.document.body.style[toCheck] !== 'undefined') {\n            return toCheck;\n        }\n    }\n    return null;\n}\n","/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to check\n * @returns {Boolean} answer to: is a function?\n */\nexport default function isFunction(functionToCheck) {\n    const getType = {};\n    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n","/**\n * Helper used to know if the given modifier depends from another one.\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nexport default function isModifierRequired(modifiers, requestingName, requestedName) {\n    // find is not supported by IE\n    const requesting = modifiers.filter(({ name }) => name === requestingName)[0];\n\n    return !!requesting && modifiers.some((modifier) => {\n      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n    });\n}\n","/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nexport default function isNumeric(n) {\n    return (n !== '' && !isNaN(parseFloat(n)) && isFinite(n));\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\nimport getParentNode from './getParentNode';\n\n/**\n * Check if the given element has transforms applied to itself or a parent\n * @method\n * @memberof Popper.Utils\n * @param  {Element} element\n * @return {Boolean} answer to \"isTransformed?\"\n */\nexport default function isTransformed(element) {\n  if (element === window.document.body) {\n      return false;\n  }\n  if (getStyleComputedProperty(element, 'transform') !== 'none') {\n      return true;\n  }\n  return getParentNode(element) ? isTransformed(getParentNode(element)) : element;\n}\n","import isFunction from './isFunction';\nimport findIndex from './findIndex';\n\n/**\n * Loop trough the list of modifiers and run them in order, each of them will then edit the data object\n * @method\n * @memberof Popper.Utils\n * @param {Object} data\n * @param {Array} modifiers\n * @param {Function} ends\n */\nexport default function runModifiers(modifiers, data, ends) {\n    const modifiersToRun = (ends === undefined) ?\n          modifiers :\n          modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n    modifiersToRun.forEach((modifier) => {\n        if (modifier.enabled && isFunction(modifier.function)) {\n            data = modifier.function(data, modifier);\n        }\n    });\n\n    return data;\n}\n","import isNumeric from './isNumeric';\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles - Object with a list of properties and values which will be applied to the element\n */\nexport default function setStyles(element, styles) {\n    Object.keys(styles).forEach(function(prop) {\n        let unit = '';\n        // add unit if the value is numeric and is one of the following\n        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n            unit = 'px';\n        }\n        element.style[prop] = styles[prop] + unit;\n    });\n}\n","import findIndex from './findIndex';\nimport getBoundaries from './getBoundaries';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport getOffsetParent from './getOffsetParent';\nimport getOffsetRectRelativeToCustomParent from './getOffsetRectRelativeToCustomParent';\nimport getOuterSizes from './getOuterSizes';\nimport getPopperClientRect from './getPopperClientRect';\nimport getPosition from './getPosition';\nimport getScrollParent from './getScrollParent';\nimport getScroll from './getScroll';\nimport getTotalScroll from './getTotalScroll';\nimport getStyleComputedProperty from './getStyleComputedProperty';\nimport getSupportedPropertyName from './getSupportedPropertyName';\nimport isFixed from './isFixed';\nimport isFunction from './isFunction';\nimport isModifierRequired from './isModifierRequired';\nimport isNumeric from './isNumeric';\nimport isTransformed from './isTransformed';\nimport runModifiers from './runModifiers';\nimport setStyles from './setStyles';\n\n/** @namespace Popper.Utils */\nexport default {\n    findIndex,\n    getBoundaries,\n    getBoundingClientRect,\n    getOffsetParent,\n    getOffsetRectRelativeToCustomParent,\n    getOuterSizes,\n    getPopperClientRect,\n    getPosition,\n    getScrollParent,\n    getScroll,\n    getTotalScroll,\n    getStyleComputedProperty,\n    getSupportedPropertyName,\n    isFixed,\n    isFunction,\n    isModifierRequired,\n    isNumeric,\n    isTransformed,\n    runModifiers,\n    setStyles,\n};\n","const nativeHints = [\n    'native code',\n    '[object MutationObserverConstructor]' // for mobile safari iOS 9.0\n];\n\n/**\n * Determine if a function is implemented natively (as opposed to a polyfill).\n * @argument {Function | undefined} fn the function to check\n * @returns {boolean}\n */\nexport default fn => nativeHints.some(hint => (fn || '').toString().indexOf(hint) > -1);","import isNative from './isNative';\n\nconst longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\nlet timeoutDuration = 0;\nfor (let i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n  if (navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n    timeoutDuration = 1;\n    break;\n  }\n}\n\nfunction microtaskDebounce(fn) {\n  let scheduled = false;\n  let i = 0;\n  const elem = document.createElement('span');\n\n  // MutationObserver provides a mechanism for scheduling microtasks, which\n  // are scheduled *before* the next task. This gives us a way to debounce\n  // a function but ensure it's called *before* the next paint.\n  const observer = new MutationObserver(() => {\n    fn();\n    scheduled = false;\n  });\n\n  observer.observe(elem, { childList: true });\n\n  return () => {\n    if (!scheduled) {\n      scheduled = true;\n      elem.textContent = `${i}`;\n      i += 1;\n    }\n  };\n}\n\nfunction taskDebounce(fn) {\n  let scheduled = false;\n  return () => {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(() => {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\n// It's common for MutationObserver polyfills to be seen in the wild, however\n// these rely on Mutation Events which only occur when an element is connected\n// to the DOM. The algorithm used in this module does not use a connected element,\n// and so we must ensure that a *native* MutationObserver is available.\nconst supportsNativeMutationObserver = isNative(window.MutationObserver);\n\n/**\n * Create a debounced version of a method, that's asynchronously deferred\n * but called in the minimum time possible.\n *\n * @method\n * @memberof Popper.Utils\n * @argument {Function} fn\n * @returns {Function}\n */\nexport default supportsNativeMutationObserver ? microtaskDebounce : taskDebounce;\n","import getOffsetParent from './getOffsetParent';\nimport getOffsetRectRelativeToCustomParent from './getOffsetRectRelativeToCustomParent';\nimport getOuterSizes from './getOuterSizes';\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nexport default function getOffsets(state, popper, reference, placement) {\n    placement = placement.split('-')[0];\n\n    const popperOffsets = {};\n    popperOffsets.position = state.position;\n\n    const isParentFixed = popperOffsets.position === 'fixed';\n    const isParentTransformed = state.isParentTransformed;\n\n    //\n    // Get reference element position\n    //\n    const offsetParent = getOffsetParent((isParentFixed && isParentTransformed) ? reference : popper);\n    const referenceOffsets = getOffsetRectRelativeToCustomParent(reference, offsetParent, isParentFixed, isParentTransformed);\n\n    //\n    // Get popper sizes\n    //\n    const popperRect = getOuterSizes(popper);\n\n    //\n    // Compute offsets of popper\n    //\n\n    // depending by the popper placement we have to compute its offsets slightly differently\n    if (['right', 'left'].indexOf(placement) !== -1) {\n        popperOffsets.top = referenceOffsets.top + referenceOffsets.height / 2 - popperRect.height / 2;\n        if (placement === 'left') {\n            popperOffsets.left = referenceOffsets.left - popperRect.width;\n        } else {\n            popperOffsets.left = referenceOffsets.right;\n        }\n    } else {\n        popperOffsets.left = referenceOffsets.left + referenceOffsets.width / 2 - popperRect.width / 2;\n        if (placement === 'top') {\n            popperOffsets.top = referenceOffsets.top - popperRect.height;\n        } else {\n            popperOffsets.top = referenceOffsets.bottom;\n        }\n    }\n\n    // Add width and height to our offsets object\n    popperOffsets.width   = popperRect.width;\n    popperOffsets.height  = popperRect.height;\n\n\n    return {\n        popper: popperOffsets,\n        reference: referenceOffsets\n    };\n}\n","import getScrollParent from './getScrollParent';\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nexport default function setupEventListeners(reference, options, state, updateBound) {\n    // NOTE: 1 DOM access here\n    state.updateBound = updateBound;\n    window.addEventListener('resize', state.updateBound, { passive: true });\n    let target = getScrollParent(reference);\n    if (target === window.document.body) {\n        target = window;\n    }\n    target.addEventListener('scroll', state.updateBound, { passive: true });\n    state.scrollElement = target;\n}\n","/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nexport default function removeEventListeners(reference, state) {\n    // NOTE: 1 DOM access here\n    window.removeEventListener('resize', state.updateBound);\n    if (state.scrollElement) {\n        state.scrollElement.removeEventListener('scroll', state.updateBound);\n    }\n    state.updateBound = null;\n    state.scrollElement = null;\n    return state;\n}\n","/**\n * Sorts the modifiers based on their `order` property\n * @method\n * @memberof Popper.Utils\n */\nexport default function sortModifiers(a, b) {\n    if (a.order < b.order) {\n        return -1;\n    } else if (a.order > b.order) {\n        return 1;\n    }\n    return 0;\n}\n","/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\n export default function isModifierEnabled(modifiers, modifierName) {\n    return modifiers.some(({ name, enabled }) => name === modifierName && enabled);\n}\n","/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles - Object with a list of properties and values which will be applied to the element\n */\nexport default function setAttributes(element, attributes) {\n    Object.keys(attributes).forEach(function(prop) {\n        const value = attributes[prop];\n        if (value !== false) {\n            element.setAttribute(prop, attributes[prop]);\n        } else {\n            element.removeAttribute(prop);\n        }\n    });\n}\n","import getSupportedPropertyName from '../utils/getSupportedPropertyName';\nimport setStyles from '../utils/setStyles';\nimport setAttributes from '../utils/setAttributes';\n\n/**\n * Apply the computed styles to the popper element\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nexport default function applyStyle(data, options) {\n    // apply the final offsets to the popper\n    // NOTE: 1 DOM access here\n    const styles = {\n        position: data.offsets.popper.position\n    };\n\n    const attributes = {\n        'x-placement': data.placement,\n    };\n\n    // round top and left to avoid blurry text\n    const left = Math.round(data.offsets.popper.left);\n    const top = Math.round(data.offsets.popper.top);\n\n    // if gpuAcceleration is set to true and transform is supported,\n    //  we use `translate3d` to apply the position to the popper we\n    // automatically use the supported prefixed version if needed\n    const prefixedProperty = getSupportedPropertyName('transform');\n    if (options.gpuAcceleration && prefixedProperty) {\n        styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n        styles.top = 0;\n        styles.left = 0;\n    }\n    // othwerise, we use the standard `left` and `top` properties\n    else {\n        styles.left =left;\n        styles.top = top;\n    }\n\n    // any property present in `data.styles` will be applied to the popper,\n    // in this way we can make the 3rd party modifiers add custom styles to it\n    // Be aware, modifiers could override the properties defined in the previous\n    // lines of this modifier!\n    Object.assign(styles, data.styles);\n    setStyles(data.instance.popper, styles);\n\n    // any property present in `data.attributes` will be applied to the popper,\n    // they will be set as HTML attributes of the element\n    Object.assign(attributes, data.attributes);\n    setAttributes(data.instance.popper, attributes);\n\n    // if the arrow style has been computed, apply the arrow style\n    if (data.offsets.arrow) {\n        setStyles(data.arrowElement, data.offsets.arrow);\n    }\n\n    return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used to add margins to the popper\n * margins needs to be calculated to get the correct popper offsets\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper.\n * @param {Object} options - Popper.js options\n */\nexport function applyStyleOnLoad(reference, popper, options) {\n    popper.setAttribute('x-placement', options.placement);\n    return options;\n}\n","import getPopperClientRect from '../utils/getPopperClientRect';\nimport getOuterSizes from '../utils/getOuterSizes';\nimport isModifierRequired from '../utils/isModifierRequired';\n\n/**\n * Modifier used to move the arrowEls on the edge of the popper to make sure them are always between the popper and the reference element\n * It will use the CSS outer size of the arrowEl element to know how many pixels of conjuction are needed\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function arrow(data, options) {\n    let arrowEl  = options.element;\n\n    // if the arrowElElement is a string, suppose it's a CSS selector\n    if (typeof arrowEl === 'string') {\n        arrowEl = data.instance.popper.querySelector(arrowEl);\n    }\n\n    // if arrowEl element is not found, don't run the modifier\n    if (!arrowEl) {\n        return data;\n    }\n\n    // the arrowEl element must be child of its popper\n    if (!data.instance.popper.contains(arrowEl)) {\n        console.warn('WARNING: `arrowElElement` must be child of its popper element!');\n        return data;\n    }\n\n    // arrowEl depends on keepTogether in order to work\n    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n        console.warn('WARNING: keepTogether modifier is required by arrow modifier in order to work, be sure to include it before arrow!');\n        return data;\n    }\n\n    const arrowElStyle  = {};\n    const placement     = data.placement.split('-')[0];\n    const popper        = getPopperClientRect(data.offsets.popper);\n    const reference     = data.offsets.reference;\n    const isVertical    = ['left', 'right'].indexOf(placement) !== -1;\n\n    const len           = isVertical ? 'height' : 'width';\n    const side          = isVertical ? 'top' : 'left';\n    const altSide       = isVertical ? 'left' : 'top';\n    const opSide        = isVertical ? 'bottom' : 'right';\n    const arrowElSize   = getOuterSizes(arrowEl)[len];\n\n    //\n    // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction\n    //\n\n    // top/left side\n    if (reference[opSide] - arrowElSize < popper[side]) {\n        data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElSize);\n    }\n    // bottom/right side\n    if (reference[side] + arrowElSize > popper[opSide]) {\n        data.offsets.popper[side] += (reference[side] + arrowElSize) - popper[opSide];\n    }\n\n    // compute center of the popper\n    const center = reference[side] + (reference[len] / 2) - (arrowElSize / 2);\n\n    // Compute the sideValue using the updated popper offsets\n    let sideValue = center - getPopperClientRect(data.offsets.popper)[side];\n\n    // prevent arrowEl from being placed not contiguously to its popper\n    sideValue = Math.max(Math.min(popper[len] - arrowElSize, sideValue), 0);\n    arrowElStyle[side] = sideValue;\n    arrowElStyle[altSide] = ''; // make sure to remove any old style from the arrowEl\n\n    data.offsets.arrow = arrowElStyle;\n    data.arrowElement = arrowEl;\n\n    return data;\n}\n","/**\n * Get the opposite placement of the given one/\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nexport default function getOppositePlacement(placement) {\n    const hash = {left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n    return placement.replace(/left|right|bottom|top/g, (matched) => hash[matched]);\n}\n","/**\n * Get the opposite placement variation of the given one/\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nexport default function getOppositeVariation(variation) {\n    if (variation === 'end') {\n        return 'start';\n    } else if (variation === 'start') {\n        return 'end';\n    }\n    return variation;\n}\n","import getOppositePlacement from '../utils/getOppositePlacement';\nimport getOppositeVariation from '../utils/getOppositeVariation';\nimport getPopperClientRect from '../utils/getPopperClientRect';\nimport getOffsets from '../utils/getOffsets';\nimport runModifiers from '../utils/runModifiers';\nimport getBoundaries from '../utils/getBoundaries';\n\n/**\n * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.\n * Requires the `preventOverflow` modifier before it in order to work.\n * **NOTE:** data.instance modifier will run all its previous modifiers everytime it tries to flip the popper!\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function flip(data, options) {\n    if (data.flipped && data.placement === data.originalPlacement) {\n        // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n        return data;\n    }\n\n    const boundaries = getBoundaries(data.instance.popper, options.padding, options.boundariesElement);\n\n    let placement = data.placement.split('-')[0];\n    let placementOpposite = getOppositePlacement(placement);\n    let variation = data.placement.split('-')[1] || '';\n\n    let flipOrder = [];\n\n    if (options.behavior === 'flip') {\n        flipOrder = [\n            placement,\n            placementOpposite\n        ];\n    } else {\n        flipOrder = options.behavior;\n    }\n\n    flipOrder.forEach((step, index) => {\n        if (placement !== step || flipOrder.length === index + 1) {\n            return data;\n        }\n\n        placement = data.placement.split('-')[0];\n        placementOpposite = getOppositePlacement(placement);\n\n        const popperOffsets = getPopperClientRect(data.offsets.popper);\n\n        // using Math.floor because the reference offsets may contain decimals we are not going to consider here\n        const flippedPosition = (\n            (placement === 'left'   && Math.floor(popperOffsets.left) < Math.floor(boundaries.left)) ||\n            (placement === 'right'  && Math.floor(popperOffsets.right) > Math.floor(boundaries.right)) ||\n            (placement === 'top'    && Math.floor(popperOffsets.top) < Math.floor(boundaries.top)) ||\n            (placement === 'bottom' && Math.floor(popperOffsets.bottom) > Math.floor(boundaries.bottom))\n        );\n\n        // flip the variation if required\n        const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n        const flippedVariation = !!options.flipVariations && (\n            (isVertical  && variation === 'start' && Math.floor(popperOffsets.left) < Math.floor(boundaries.left)) ||\n            (isVertical  && variation === 'end'   && Math.floor(popperOffsets.right) > Math.floor(boundaries.right)) ||\n            (!isVertical && variation === 'start' && Math.floor(popperOffsets.top) < Math.floor(boundaries.top)) ||\n            (!isVertical && variation === 'end'   && Math.floor(popperOffsets.bottom) > Math.floor(boundaries.bottom))\n        );\n\n        if (flippedPosition || flippedVariation) {\n            // this boolean to detect any flip loop\n            data.flipped = true;\n\n            if (flippedPosition) {\n                placement = flipOrder[index + 1];\n            }\n\n            if (flippedVariation) {\n                variation = getOppositeVariation(variation);\n            }\n\n            data.placement = placement + (variation ? '-' + variation : '');\n            data.offsets.popper = getOffsets(data.instance.state, data.instance.popper, data.instance.reference, data.placement).popper;\n\n            data = runModifiers(data.instance.modifiers, data, 'flip');\n        }\n    });\n    return data;\n}\n","import getPopperClientRect from '../utils/getPopperClientRect';\n\n/**\n * Modifier used to make sure the popper is always near its reference element\n * It cares only about the first axis, you can still have poppers with margin\n * between the popper and its reference element.\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function keepTogether(data) {\n    const popper  = getPopperClientRect(data.offsets.popper);\n    const reference = data.offsets.reference;\n    const f = Math.floor;\n    const placement = data.placement.split('-')[0];\n\n    if (['top', 'bottom'].indexOf(placement) !== -1) {\n        if (popper.right < f(reference.left)) {\n            data.offsets.popper.left = f(reference.left) - popper.width;\n        }\n        if (popper.left > f(reference.right)) {\n            data.offsets.popper.left = f(reference.right);\n        }\n    } else {\n        if (popper.bottom < f(reference.top)) {\n            data.offsets.popper.top = f(reference.top) - popper.height;\n        }\n        if (popper.top > f(reference.bottom)) {\n            data.offsets.popper.top = f(reference.bottom);\n        }\n    }\n\n    return data;\n}\n","import isNumeric from '../utils/isNumeric';\nimport getPopperClientRect from '../utils/getPopperClientRect';\n\n/**\n * Modifier used to add an offset to the popper, useful if you more granularity positioning your popper.\n * The offsets will shift the popper on the side of its reference element.\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n *      Basic usage allows a number used to nudge the popper by the given amount of pixels.\n *      You can pass a percentage value as string (eg. `20%`) to nudge by the given percentage (relative to reference element size)\n *      Other supported units are `vh` and `vw` (relative to viewport)\n *      Additionally, you can pass a pair of values (eg. `10 20` or `2vh 20%`) to nudge the popper\n *      on both axis.\n *      A note about percentage values, if you want to refer a percentage to the popper size instead of the reference element size,\n *      use `%p` instead of `%` (eg: `20%p`). To make it clearer, you can replace `%` with `%r` and use eg.`10%p 25%r`.\n *      > **Heads up!** The order of the axis is relative to the popper placement: `bottom` or `top` are `X,Y`, the other are `Y,X`\n * @returns {Object} The data object, properly modified\n */\nexport default function offset(data, options) {\n    const placement = data.placement;\n    const popper  = data.offsets.popper;\n\n    let offsets;\n    if (isNumeric(options.offset)) {\n        offsets = [options.offset, 0];\n    } else {\n        // split the offset in case we are providing a pair of offsets separated\n        // by a blank space\n        offsets = options.offset.split(' ');\n\n        // itherate through each offset to compute them in case they are percentages\n        offsets = offsets.map((offset, index) => {\n            // separate value from unit\n            const split = offset.match(/(\\d*\\.?\\d*)(.*)/);\n            const value = +split[1];\n            const unit = split[2];\n\n            // use height if placement is left or right and index is 0\n            // otherwise use height\n            // in this way the first offset will use an axis and the second one\n            // will use the other one\n            let useHeight = placement.indexOf('right') !== -1 || placement.indexOf('left') !== -1;\n\n            if (index === 1) {\n                useHeight = !useHeight;\n            }\n\n            // if is a percentage, we calculate the value of it using as base the\n            // sizes of the reference element\n            if (unit === '%' || unit === '%r') {\n                const referenceRect = getPopperClientRect(data.offsets.reference);\n                let len;\n                if (useHeight) {\n                    len = referenceRect.height;\n                } else {\n                    len = referenceRect.width;\n                }\n                return (len / 100) * value;\n            }\n            // if is a percentage relative to the popper, we calculate the value of it using\n            // as base the sizes of the popper\n            else if (unit === '%p') {\n                const popperRect = getPopperClientRect(data.offsets.popper);\n                let len;\n                if (useHeight) {\n                    len = popperRect.height;\n                } else {\n                    len = popperRect.width;\n                }\n                return (len / 100) * value;\n            }\n            // if is a vh or vw, we calculate the size based on the viewport\n            else if (unit === 'vh' || unit === 'vw') {\n                let size;\n                if (unit === 'vh') {\n                    size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n                } else {\n                    size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n                }\n                return (size / 100) * value;\n            }\n            // if is an explicit pixel unit, we get rid of the unit and keep the value\n            else if (unit === 'px') {\n                return +value;\n            }\n            // if is an implicit unit, it's px, and we return just the value\n            else {\n                return +offset;\n            }\n        });\n    }\n\n    if (data.placement.indexOf('left') !== -1) {\n        popper.top += offsets[0];\n        popper.left -= offsets[1] || 0;\n    }\n    else if (data.placement.indexOf('right') !== -1) {\n        popper.top += offsets[0];\n        popper.left += offsets[1] || 0;\n    }\n    else if (data.placement.indexOf('top') !== -1) {\n        popper.left += offsets[0];\n        popper.top -= offsets[1] || 0;\n    }\n    else if (data.placement.indexOf('bottom') !== -1) {\n        popper.left += offsets[0];\n        popper.top += offsets[1] || 0;\n    }\n    return data;\n}\n","import getPopperClientRect from '../utils/getPopperClientRect';\nimport getOppositePlacement from '../utils/getOppositePlacement';\nimport getOffsetParent from '../utils/getOffsetParent';\nimport getBoundaries from '../utils/getBoundaries';\n\n/**\n * Modifier used to prevent the popper from being positioned outside the boundary.\n *\n * An scenario exists where the reference itself is not within the boundaries. We can\n * say it has \"escaped the boundaries\" â€” or just \"escaped\". In this case we need to\n * decide whether the popper should either:\n *\n * - detach from the reference and remain \"trapped\" in the boundaries, or\n * - if it should be ignore the boundary and \"escape with the reference\"\n *\n * When `escapeWithReference` is `true`, and reference is completely outside the\n * boundaries, the popper will overflow (or completely leave) the boundaries in order\n * to remain attached to the edge of the reference.\n *\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function preventOverflow(data, options) {\n    const boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n    const boundaries = getBoundaries(data.instance.popper, options.padding, boundariesElement);\n    options.boundaries = boundaries;\n\n    const order = options.priority;\n    const popper = getPopperClientRect(data.offsets.popper);\n\n    const check = {\n        left() {\n            let left = popper.left;\n            if (popper.left < boundaries.left && !shouldOverflowBoundary(data, options, 'left')) {\n                left = Math.max(popper.left, boundaries.left);\n            }\n            return { left };\n        },\n        right() {\n            let left = popper.left;\n            if (popper.right > boundaries.right && !shouldOverflowBoundary(data, options, 'right')) {\n                left = Math.min(popper.left, boundaries.right - popper.width);\n            }\n            return { left };\n        },\n        top() {\n            let top = popper.top;\n            if (popper.top < boundaries.top && !shouldOverflowBoundary(data, options, 'top')) {\n                top = Math.max(popper.top, boundaries.top);\n            }\n            return { top };\n        },\n        bottom() {\n            let top = popper.top;\n            if (popper.bottom > boundaries.bottom && !shouldOverflowBoundary(data, options, 'bottom')) {\n                top = Math.min(popper.top, boundaries.bottom - popper.height);\n            }\n            return { top };\n        }\n    };\n\n    order.forEach((direction) => {\n        data.offsets.popper = Object.assign(\n            popper,\n            check[direction]()\n        );\n    });\n\n    return data;\n}\n\n/**\n * Determine if the popper should overflow a boundary edge to stay together with the reference.\n */\nfunction shouldOverflowBoundary(data, options, overflowDirection) {\n    if (!options.escapeWithReference) {\n        return false;\n    }\n\n    if (data.flipped && isSameAxis(data.originalPlacement, overflowDirection)) {\n        return true;\n    }\n\n    if (!isSameAxis(data.originalPlacement, overflowDirection)) {\n        return true;\n    }\n\n    return true;\n}\n\n/**\n * Determine if two placement values are on the same axis.\n */\nfunction isSameAxis(a, b) {\n    // placement syntax:\n    //\n    //     ( \"top\" | \"right\" | \"bottom\" | \"left\" ) ( \"-start\" | \"\" | \"-end\" )\n    //     |------------- Direction -------------|\n    //\n    const aDirection = a.split('-')[0];\n    const bDirection = b.split('-')[0];\n\n    return aDirection === bDirection || aDirection === getOppositePlacement(b);\n}\n","import getPopperClientRect from '../utils/getPopperClientRect';\n\n/**\n * Modifier used to shift the popper on the start or end of its reference element side\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function shift(data) {\n    const placement = data.placement;\n    const basePlacement = placement.split('-')[0];\n    const shiftvariation = placement.split('-')[1];\n\n    // if shift shiftvariation is specified, run the modifier\n    if (shiftvariation) {\n        const reference = data.offsets.reference;\n        const popper = getPopperClientRect(data.offsets.popper);\n\n        const shiftOffsets = {\n            y: {\n                start:  { top: reference.top },\n                end:    { top: reference.top + reference.height - popper.height }\n            },\n            x: {\n                start:  { left: reference.left },\n                end:    { left: reference.left + reference.width - popper.width }\n            }\n        };\n\n        const axis = ['bottom', 'top'].indexOf(basePlacement) !== -1 ? 'x' : 'y';\n\n        data.offsets.popper = Object.assign(popper, shiftOffsets[axis][shiftvariation]);\n    }\n\n    return data;\n}\n","import isModifierRequired from '../utils/isModifierRequired';\n\n/**\n * Modifier used to hide the popper when its reference element is outside of the\n * popper boundaries. It will set an x-hidden attribute which can be used to hide\n * the popper when its reference is out of boundaries.\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function hide(data) {\n    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n        console.warn('WARNING: preventOverflow modifier is required by hide modifier in order to work, be sure to include it before hide!');\n        return data;\n    }\n\n    const refRect = data.offsets.reference;\n    const bound = data.instance.modifiers.filter((modifier) => modifier.name ==='preventOverflow')[0].boundaries;\n\n    if (\n        refRect.bottom < bound.top ||\n        refRect.left > bound.right ||\n        refRect.top > bound.bottom ||\n        refRect.right < bound.left\n    ) {\n        // Avoid unnecessary DOM access if visibility hasn't changed\n        if (data.hide === true) { return data; }\n\n        data.hide = true;\n        data.attributes['x-out-of-boundaries'] = '';\n    } else {\n        // Avoid unnecessary DOM access if visibility hasn't changed\n        if (data.hide === false) { return data; }\n\n        data.hide = false;\n        data.attributes['x-out-of-boundaries'] = false;\n    }\n\n    return data;\n}\n","import applyStyle from './applyStyle';\nimport arrow from './arrow';\nimport flip from './flip';\nimport keepTogether from './keepTogether';\nimport offset from './offset';\nimport preventOverflow from './preventOverflow';\nimport shift from './shift';\nimport hide from './hide';\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.\n * Popper.js uses a set of 7 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Each modifier is an object containing several properties listed below.\n * @namespace Modifiers\n * @param {Object} modifier - Modifier descriptor\n * @param {Integer} modifier.order\n *      The `order` property defines the execution order of the modifiers.\n *      The built-in modifiers have orders with a gap of 100 units in between,\n *      this allows you to inject additional modifiers between the existing ones\n *      without having to redefine the order of all of them.\n *      The modifiers are executed starting from the one with the lowest order.\n * @param {Boolean} modifier.enabled - When `true`, the modifier will be used.\n * @param {Modifiers~modifier} modifier.function - Modifier function.\n * @param {Modifiers~onLoad} modifier.onLoad - Function executed on popper initalization\n * @return {Object} data - Each modifier must return the modified `data` object.\n */\n\nexport default {\n    applyStyle,\n    arrow,\n    flip,\n    keepTogether,\n    offset,\n    preventOverflow,\n    shift,\n    hide,\n};\n\nimport { applyStyleOnLoad } from './applyStyle';\n\nexport const modifiersOnLoad = {\n    applyStyleOnLoad,\n};\n\n\n/**\n * Modifiers can edit the `data` object to change the beheavior of the popper.\n * This object contains all the informations used by Popper.js to compute the\n * popper position.\n * The modifier can edit the data as needed, and then `return` it as result.\n *\n * @callback Modifiers~modifier\n * @param {dataObject} data\n * @return {dataObject} modified data\n */\n\n\n/**\n * The `dataObject` is an object containing all the informations used by Popper.js\n * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements.\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arro] `top` and `left` offsets, only one of them will be different from 0\n */\n","// Polyfills\nimport './polyfills/objectAssign';\nimport './polyfills/requestAnimationFrame';\n\n// Utils\nimport Utils from './utils/index';\nimport debounce from './utils/debounce';\nimport setStyles from './utils/setStyles';\nimport isTransformed from './utils/isTransformed';\nimport getSupportedPropertyName from './utils/getSupportedPropertyName';\nimport getPosition from './utils/getPosition';\nimport getOffsets from './utils/getOffsets';\nimport isFunction from './utils/isFunction';\nimport setupEventListeners from './utils/setupEventListeners';\nimport removeEventListeners from './utils/removeEventListeners';\nimport runModifiers from './utils/runModifiers';\nimport sortModifiers from './utils/sortModifiers';\nimport isModifierEnabled from './utils/isModifierEnabled';\n\n// Modifiers\nimport modifiersFunctions from './modifiers/index';\nimport { modifiersOnLoad as modifiersOnLoadFunctions } from './modifiers/index';\n\n// default options\nvar DEFAULTS = {\n    // placement of the popper\n    placement: 'bottom',\n\n    /**\n     * Callback called when the popper is created.\n     * By default, is set to no-op.\n     * Access Popper.js instance with `data.instance`.\n     * @callback createCallback\n     * @static\n     * @param {dataObject} data\n     */\n    onCreate: () => {},\n\n    /**\n     * Callback called when the popper is updated, this callback is not called\n     * on the initialization/creation of the popper, but only on subsequent\n     * updates.\n     * By default, is set to no-op.\n     * Access Popper.js instance with `data.instance`.\n     * @callback updateCallback\n     * @static\n     * @param {dataObject} data\n     */\n    onUpdate: () => {},\n\n    // list of functions used to modify the offsets before they are applied to the popper\n    modifiers: {\n        shift: {\n            order: 100,\n            enabled: true,\n            function: modifiersFunctions.shift,\n        },\n        offset: {\n            order: 200,\n            enabled: true,\n            function: modifiersFunctions.offset,\n            // nudges popper from its origin by the given amount of pixels (can be negative)\n            offset: 0,\n        },\n        preventOverflow: {\n            order: 300,\n            enabled: true,\n            function: modifiersFunctions.preventOverflow,\n            // popper will try to prevent overflow following these priorities\n            //  by default, then, it could overflow on the left and on top of the boundariesElement\n            priority: ['left', 'right', 'top', 'bottom'],\n            // amount of pixel used to define a minimum distance between the boundaries and the popper\n            // this makes sure the popper has always a little padding between the edges of its container\n            padding: 5,\n            boundariesElement: 'scrollParent',\n        },\n        keepTogether: {\n            order: 400,\n            enabled: true,\n            function: modifiersFunctions.keepTogether\n        },\n        arrow: {\n            order: 500,\n            enabled: true,\n            function: modifiersFunctions.arrow,\n            // selector or node used as arrow\n            element: '[x-arrow]'\n        },\n        flip: {\n            order: 600,\n            enabled: true,\n            function: modifiersFunctions.flip,\n            // the behavior used to change the popper's placement\n            behavior: 'flip',\n            // the popper will flip if it hits the edges of the boundariesElement - padding\n            padding: 5,\n            boundariesElement: 'viewport'\n        },\n        hide: {\n            order: 700,\n            enabled: true,\n            function: modifiersFunctions.hide\n        },\n        applyStyle: {\n            order: 800,\n            enabled: true,\n            // if true, it uses the CSS 3d transformation to position the popper\n            gpuAcceleration: true,\n            function: modifiersFunctions.applyStyle,\n            onLoad: modifiersOnLoadFunctions.applyStyleOnLoad\n        }\n    },\n};\n\n/**\n * Create a new Popper.js instance\n * @class Popper\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper.\n * @param {Object} options\n * @param {String} options.placement=bottom\n *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -right),\n *      left(-start, -end)`\n *\n * @param {Boolean} options.gpuAcceleration=true\n *      When this property is set to true, the popper position will be applied using CSS3 translate3d, allowing the\n *      browser to use the GPU to accelerate the rendering.\n *      If set to false, the popper will be placed using `top` and `left` properties, not using the GPU.\n *\n * @param {Number} options.boundariesPadding=5\n *      Additional padding for the boundaries\n *\n * @param {Boolean} options.removeOnDestroy=false\n *      Set to true if you want to automatically remove the popper when you call the `destroy` method.\n *\n * @param {Object} options.modifiers\n *      List of functions used to modify the data before they are applied to the popper (see source code for default values)\n *\n * @param {Object} options.modifiers.arrow - Arrow modifier configuration\n * @param {HTMLElement|String} options.modifiers.arrow.element='[x-arrow]'\n *      The DOM Node used as arrow for the popper, or a CSS selector used to get the DOM node. It must be child of\n *      its parent Popper. Popper.js will apply to the given element the style required to align the arrow with its\n *      reference element.\n *      By default, it will look for a child node of the popper with the `x-arrow` attribute.\n *\n * @param {Object} options.modifiers.offset - Offset modifier configuration\n * @param {Number} options.modifiers.offset.offset=0\n *      Amount of pixels the popper will be shifted (can be negative).\n *\n * @param {Object} options.modifiers.preventOverflow - PreventOverflow modifier configuration\n * @param {Array} [options.modifiers.preventOverflow.priority=['left', 'right', 'top', 'bottom']]\n *      Priority used when Popper.js tries to avoid overflows from the boundaries, they will be checked in order,\n *      this means that the last one will never overflow\n * @param {Number} options.modifiers.preventOverflow.padding=5\n *      Amount of pixel used to define a minimum distance between the boundaries and the popper\n *      this makes sure the popper has always a little padding between the edges of its container.\n *\n * @param {Object} options.modifiers.flip - Flip modifier configuration\n * @param {String|Array} options.modifiers.flip.behavior='flip'\n *      The behavior used by the `flip` modifier to change the placement of the popper when the latter is trying to\n *      overlap its reference element. Defining `flip` as value, the placement will be flipped on\n *      its axis (`right - left`, `top - bottom`).\n *      You can even pass an array of placements (eg: `['right', 'left', 'top']` ) to manually specify\n *      how alter the placement when a flip is needed. (eg. in the above example, it would first flip from right to left,\n *      then, if even in its new placement, the popper is overlapping its reference element, it will be moved to top)\n * @param {String|Element} options.modifiers.flip.boundariesElement='viewport'\n *      The element which will define the boundaries of the popper position, the popper will never be placed outside\n *      of the defined boundaries (except if `keepTogether` is enabled)\n *\n * @param {Number} options.modifiers.flip.padding=5\n *      Amount of pixel used to define a minimum distance between the boundaries and the popper\n *      this makes sure the popper has always a little padding between the edges of its container.\n *\n * @return {Object} instance - The generated Popper.js instance\n */\nexport default class Popper {\n    constructor(reference, popper, options = {}) {\n        // make update() debounced, so that it only runs at most once-per-tick\n        this.update = debounce(this.update.bind(this));\n\n        // init state\n        this.state = {\n            isDestroyed: false,\n            isCreated: false,\n        };\n\n        // get reference and popper elements (allow jQuery wrappers)\n        this.reference = reference.jquery ? reference[0] : reference;\n        this.popper = popper.jquery ? popper[0] : popper;\n\n        // with {} we create a new object with the options inside it\n        this.options = Object.assign({}, DEFAULTS, options);\n\n        // refactoring modifiers' list (Object => Array)\n        this.modifiers = Object.keys(DEFAULTS.modifiers)\n                               .map((name) => Object.assign({ name }, DEFAULTS.modifiers[name]));\n\n        // assign default values to modifiers, making sure to override them with\n        // the ones defined by user\n        this.modifiers = this.modifiers.map((defaultConfig) => {\n            const userConfig = (options.modifiers && options.modifiers[defaultConfig.name]) || {};\n            const finalConfig = Object.assign({}, defaultConfig, userConfig);\n            return finalConfig;\n        });\n\n        // add custom modifiers to the modifiers list\n        if (options.modifiers) {\n            this.options.modifiers = Object.assign({}, DEFAULTS.modifiers, options.modifiers);\n            Object.keys(options.modifiers).forEach((name) => {\n                // take in account only custom modifiers\n                if (DEFAULTS.modifiers[name] === undefined) {\n                    const modifier = options.modifiers[name];\n                    modifier.name = name;\n                    this.modifiers.push(modifier);\n                }\n            });\n        }\n\n        // sort the modifiers by order\n        this.modifiers = this.modifiers.sort(sortModifiers)\n\n        // modifiers have the ability to execute arbitrary code when Popper.js get inited\n        // such code is executed in the same order of its modifier\n        // they could add new properties to their options configuration\n        // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n        this.modifiers.forEach((modifier) => {\n            if (modifier.enabled && isFunction(modifier.onLoad)) {\n                //              reference       popper       options       modifierOptions\n                modifier.onLoad(this.reference, this.popper, this.options, modifier);\n            }\n        });\n\n\n        // get the popper position type\n        this.state.position = getPosition(this.reference);\n\n        // determine how we should set the origin of offsets\n        this.state.isParentTransformed = isTransformed(this.popper.parentNode);\n\n        // fire the first update to position the popper in the right place\n        this.update();\n\n        // setup event listeners, they will take care of update the position in specific situations\n        setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n    }\n\n    //\n    // Methods\n    //\n\n    /**\n     * Updates the position of the popper, computing the new offsets and applying the new style\n     * Prefer `scheduleUpdate` over `update` because of performance reasons\n     * @method\n     * @memberof Popper\n     */\n    update() {\n        let data = {\n            instance: this,\n            styles: {},\n            attributes: {},\n            flipped: false,\n        };\n\n        // make sure to apply the popper position before any computation\n        this.state.position = getPosition(this.reference);\n        setStyles(this.popper, { position: this.state.position});\n\n        // if popper is destroyed, don't perform any further update\n        if (this.state.isDestroyed) { return; }\n\n        // store placement inside the data object, modifiers will be able to edit `placement` if needed\n        // and refer to originalPlacement to know the original value\n        data.placement = this.options.placement;\n        data.originalPlacement = this.options.placement;\n\n        // compute the popper and reference offsets and put them inside data.offsets\n        data.offsets = getOffsets(this.state, this.popper, this.reference, data.placement);\n\n        // run the modifiers\n        data = runModifiers(this.modifiers, data);\n\n        // the first `update` will call `onCreate` callback\n        // the other ones will call `onUpdate` callback\n        if (!this.state.isCreated) {\n            this.state.isCreated = true;\n            this.options.onCreate(data);\n        } else {\n            this.options.onUpdate(data);\n        }\n    }\n\n    /**\n     * Schedule an update, it will run on the next UI update available\n     * @method\n     * @memberof Popper\n     */\n    scheduleUpdate = () => this.scheduledUpdate = requestAnimationFrame(this.update);\n\n    /**\n     * Destroy the popper\n     * @method\n     * @memberof Popper\n     */\n    destroy() {\n        this.state.isDestroyed = true;\n\n        // touch DOM only if `applyStyle` modifier is enabled\n        if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n            this.popper.removeAttribute('x-placement');\n            this.popper.style.left = '';\n            this.popper.style.position = '';\n            this.popper.style.top = '';\n            this.popper.style[getSupportedPropertyName('transform')] = '';\n        }\n\n        cancelAnimationFrame(this.scheduledUpdate);\n        this.state = removeEventListeners(this.reference, this.state);\n\n        // remove the popper if user explicity asked for the deletion on destroy\n        // do not use `remove` because IE11 doesn't support it\n        if (this.options.removeOnDestroy) {\n            this.popper.parentNode.removeChild(this.popper);\n        }\n        return this;\n    }\n\n    /**\n     * Collection of utilities useful when writing custom modifiers\n     * @memberof Popper\n     */\n    static Utils = Utils;\n\n    /**\n     * List of accepted placements to use as values of the `placement` option\n     * @memberof Popper\n     */\n     static placements = [\n         'top',\n         'top-start',\n         'top-end',\n         'right',\n         'right-start',\n         'right-end',\n         'bottom',\n         'bottom-start',\n         'bottom-end',\n         'left',\n         'left-start',\n         'left-end',\n     ];\n\n    /**\n     * Default Popper.js options\n     * @memberof Popper\n     */\n    Defaults = DEFAULTS;\n}\n"],"names":["Object","assign","defineProperty","target","undefined","TypeError","to","i","arguments","length","nextSource","keysArray","keys","nextIndex","len","nextKey","desc","getOwnPropertyDescriptor","enumerable","window","requestAnimationFrame","lastTime","vendors","x","cancelAnimationFrame","callback","currTime","Date","getTime","timeToCall","Math","max","id","setTimeout","findIndex","arr","prop","value","match","filter","obj","indexOf","getOffsetParent","element","offsetParent","nodeName","document","documentElement","getStyleComputedProperty","property","nodeType","css","getComputedStyle","getParentNode","parentNode","host","getScrollParent","scrollingElement","body","getOffsetRect","html","elementRect","clientWidth","innerWidth","clientHeight","innerHeight","offsetWidth","offsetHeight","offsetLeft","offsetTop","right","left","width","bottom","top","height","isFixed","getPosition","container","isParentFixed","getBoundingClientRect","rect","navigator","appVersion","horizScrollbar","vertScrollbar","getScroll","side","upperSide","getOffsetRectRelativeToCustomParent","parent","fixed","transformed","scrollParent","parentRect","scrollTop","scrollLeft","contains","getTotalScroll","scroll","getBoundaries","popper","padding","boundariesElement","boundaries","scrollHeight","scrollWidth","offsetParentRect","position","getOuterSizes","display","style","visibility","styles","parseFloat","marginTop","marginBottom","y","marginLeft","marginRight","result","getPopperClientRect","popperOffsets","getSupportedPropertyName","prefixes","toCheck","charAt","toUpperCase","slice","isFunction","functionToCheck","getType","toString","call","isModifierRequired","modifiers","requestingName","requestedName","requesting","name","some","modifier","enabled","order","isNumeric","n","isNaN","isFinite","isTransformed","runModifiers","data","ends","modifiersToRun","forEach","function","setStyles","unit","nativeHints","fn","hint","longerTimeoutBrowsers","timeoutDuration","userAgent","microtaskDebounce","scheduled","elem","createElement","observer","MutationObserver","observe","childList","textContent","taskDebounce","supportsNativeMutationObserver","isNative","getOffsets","state","reference","placement","split","isParentTransformed","referenceOffsets","popperRect","setupEventListeners","options","updateBound","addEventListener","passive","scrollElement","removeEventListeners","removeEventListener","sortModifiers","a","b","isModifierEnabled","modifierName","setAttributes","attributes","setAttribute","removeAttribute","applyStyle","offsets","round","prefixedProperty","gpuAcceleration","instance","arrow","arrowElement","applyStyleOnLoad","arrowEl","querySelector","warn","arrowElStyle","isVertical","altSide","opSide","arrowElSize","center","sideValue","min","getOppositePlacement","hash","replace","matched","getOppositeVariation","variation","flip","flipped","originalPlacement","placementOpposite","flipOrder","behavior","step","index","flippedPosition","floor","flippedVariation","flipVariations","keepTogether","f","offset","map","useHeight","referenceRect","size","preventOverflow","priority","check","shouldOverflowBoundary","direction","overflowDirection","escapeWithReference","isSameAxis","aDirection","bDirection","shift","basePlacement","shiftvariation","shiftOffsets","axis","hide","refRect","bound","modifiersOnLoad","DEFAULTS","modifiersFunctions","modifiersOnLoadFunctions","Popper","scheduleUpdate","scheduledUpdate","update","Defaults","debounce","bind","jquery","defaultConfig","userConfig","finalConfig","push","sort","onLoad","isDestroyed","isCreated","onCreate","onUpdate","removeOnDestroy","removeChild","Utils","placements"],"mappings":"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"}