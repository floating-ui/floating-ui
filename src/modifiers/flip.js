import getOppositePlacement from '../utils/getOppositePlacement';
import getOppositeVariation from '../utils/getOppositeVariation';
import getPopperClientRect from '../utils/getPopperClientRect';
import getOffsets from '../utils/getOffsets';
import runModifiers from '../utils/runModifiers';
import getBoundaries from '../utils/getBoundaries';

/**
 * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.
 * Requires the `preventOverflow` modifier before it in order to work.
 * **NOTE:** data.instance modifier will run all its previous modifiers everytime it tries to flip the popper!
 * @method
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
export default function flip(data, options) {
    if (data.flipped && data.placement === data.originalPlacement) {
        // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
        return data;
    }

    let placement = data.placement.split('-')[0];
    let placementOpposite = getOppositePlacement(placement);
    let variation = data.placement.split('-')[1] || '';

    let flipOrder = [];

    if(options.behavior === 'flip') {
        flipOrder = [
            placement,
            placementOpposite
        ];
    } else {
        flipOrder = options.behavior;
    }

    flipOrder.forEach((step, index) => {
        if (placement !== step || flipOrder.length === index + 1) {
            return data;
        }

        placement = data.placement.split('-')[0];
        placementOpposite = getOppositePlacement(placement);

        const popperOffsets = getPopperClientRect(data.offsets.popper);

        // this boolean is used to distinguish right and bottom from top and left
        // they need different computations to get flipped
        const a = ['right', 'bottom'].indexOf(placement) !== -1;
        const b = ['top', 'bottom'].indexOf(placement) !== -1;

        // using Math.floor because the reference offsets may contain decimals we are not going to consider here
        const flippedPosition = a && Math.floor(popperOffsets[placement]) > Math.floor(options.boundaries[placement]) ||
            !a && Math.floor(popperOffsets[placement]) < Math.floor(options.boundaries[placement]);

        const flippedVariation = options.flipVariations && (
            b && (variation === 'start') && Math.floor(popperOffsets.left) < Math.floor(options.boundaries.left) ||
            b && (variation === 'end') && Math.floor(popperOffsets.right) > Math.floor(options.boundaries.right) ||
            !b && (variation === 'start') && Math.floor(popperOffsets.top) < Math.floor(options.boundaries.top) ||
            !b && (variation === 'end') && Math.floor(popperOffsets.bottom) > Math.floor(options.boundaries.bottom));

        if (
            flippedPosition || flippedVariation
        ) {
            // this boolean to detect any flip loop
            data.flipped = true;

            if (flippedPosition) {
                placement = flipOrder[index + 1];
            }
            if (flippedVariation) {
                variation = getOppositeVariation(variation);
            }

            data.placement = placement + (variation ? '-' + variation : '');
            data.offsets.popper = getOffsets(data.instance.state, data.instance.popper, data.instance.reference, data.placement).popper;

            data = runModifiers(data.instance.modifiers, data, 'flip');
        }
    });
    return data;
}

export function flipOnLoad(reference, popper, options, modifierOptions) {
    // get boundaries
    modifierOptions.boundaries = getBoundaries(popper, modifierOptions.padding, modifierOptions.boundariesElement);
}
