import getOppositePlacement from '../utils/getOppositePlacement';
import getPopperClientRect from '../utils/getPopperClientRect';
import getOffsets from '../utils/getOffsets';
import isModifierRequired from '../utils/isModifierRequired';
import runModifiers from '../utils/runModifiers';

/**
 * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.
 * Requires the `preventOverflow` modifier before it in order to work.
 * **NOTE:** data.instance modifier will run all its previous modifiers everytime it tries to flip the popper!
 * @method
 * @memberof Popper.modifiers
 * @argument {Object} data - The data object generated by _update method
 * @returns {Object} The data object, properly modified
 */
export default function flip(data) {
    // check if preventOverflow is in the list of modifiers before the flip modifier.
    // otherwise flip would not work as expected.
    if (!isModifierRequired(data.instance.modifiers, 'flip', 'preventOverflow')) {
        console.warn('WARNING: preventOverflow modifier is required by flip modifier in order to work, be sure to include it before flip!');
        return data;
    }

    if (data.flipped && data.placement === data.originalPlacement) {
        // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
        return data;
    }

    let placement = data.placement.split('-')[0];
    let placementOpposite = getOppositePlacement(placement);
    const constiation = data.placement.split('-')[1] || '';

    let flipOrder = [];
    if(data.instance.options.flipBehavior === 'flip') {
        flipOrder = [
            placement,
            placementOpposite
        ];
    } else {
        flipOrder = data.instance.options.flipBehavior;
    }

    flipOrder.forEach((step, index) => {
        if (placement !== step || flipOrder.length === index + 1) {
            return data;
        }

        placement = data.placement.split('-')[0];
        placementOpposite = getOppositePlacement(placement);

        const popperOffsets = getPopperClientRect(data.offsets.popper);

        // this boolean is used to distinguish right and bottom from top and left
        // they need different computations to get flipped
        const a = ['right', 'bottom'].indexOf(placement) !== -1;

        // using Math.floor because the reference offsets may contain decimals we are not going to consider here
        if (
            a && Math.floor(data.offsets.reference[placement]) > Math.floor(popperOffsets[placementOpposite]) ||
            !a && Math.floor(data.offsets.reference[placement]) < Math.floor(popperOffsets[placementOpposite])
        ) {
            // this boolean to detect any flip loop
            data.flipped = true;
            data.placement = flipOrder[index + 1];
            if (constiation) {
                data.placement += '-' + constiation;
            }
            data.offsets.popper = getOffsets(data.instance.state, data.instance.popper, data.instance.reference, data.placement).popper;

            data = runModifiers(data.instance.modifiers, data.instance.options, data, 'flip');
        }
    });
    return data;
}
