<PageCard>

# React Native

This package provides React Native bindings for
`@floating-ui/core` — a library that provides anchor positioning
for a floating element to position it next to a given reference
element.

```bash
npm install @floating-ui/react-native
```

</PageCard>

## Usage

The `useFloating(){:js}` hook accepts all of
[`computePosition`'s options](/docs/computePosition#options)
excluding `strategy{:.key}`.

```jsx
import {View, Text} from 'react-native';
import {useFloating, shift} from '@floating-ui/react-native';

function App() {
  const {refs, floatingStyles} = useFloating({
    middleware: [shift()],
  });

  return (
    <>
      <View ref={refs.setReference} collapsable={false}>
        <Text>Reference</Text>
      </View>

      <View
        ref={refs.setFloating}
        collapsable={false}
        style={floatingStyles}
      >
        <Text>Floating</Text>
      </View>
    </>
  );
}
```

This will position the floating element at the **bottom center**
of the reference element by default.

Positioning is relative to the window by default using React
Native's
[`measureInWindow`](https://reactnative.dev/docs/0.77/the-new-architecture/layout-measurements#measureinwindowcallback)
API.

- `refs.setReference{:js}` is the reference (or anchor) element
  that is being referred to for positioning.
- `refs.setFloating{:js}` is the floating element that is being
  positioned relative to the reference element.
- `floatingStyles{:js}` is an object of positioning styles to
  apply to the floating element's `style{:.keyword}` prop.

The refs are functions to make them **reactive** — this ensures
changes to the reference or floating elements, such as with
conditional rendering, are handled correctly by updating the
position.

### Platform behavior

1. **Default (recommended)**: `measureInWindow: true{:.key}` and
   render the floating element as a sibling of the app root
   (portal it out of app content). This assumes window-origin
   positioning (not inside an offset layout wrapper such as a
   screen body/header container). This is the safest setup across
   platforms, and required for Android positioning.
2. **Non-default** `measureInWindow: false{:.key}`: use this when
   the floating element is not portaled as a root sibling. This
   path uses React Native's `measure(){:js}` API, which is broken
   on Android. Use it only when Android support is not required.

<Notice gap="above">
  `<View collapsable={false} />{:js}` allows measurements to work
  on Android. [More info here](https://github.com/facebook/react-native/issues/29712).
</Notice>

## ScrollView

When your floating element is portaled to the app root, while the
reference element is inside a `<ScrollView />{:jsx}`, spread
`scrollProps{:.const}` to the component:

```jsx /scrollProps/ {5}
import {View, Text, ScrollView} from 'react-native';
import {useFloating} from '@floating-ui/react-native';

function App() {
  const {refs, floatingStyles, scrollProps} = useFloating();

  return (
    <View>
      <ScrollView {...scrollProps}>
        <View ref={refs.setReference} collapsable={false}>
          <Text>Reference</Text>
        </View>
      </ScrollView>

      <View
        ref={refs.setFloating}
        collapsable={false}
        style={floatingStyles}
      >
        <Text>Floating</Text>
      </View>
    </View>
  );
}
```

For Android support, keep the default
`measureInWindow: true{:.key}` and portal the floating element to
the app root.

If both elements live in the same `<ScrollView />{:jsx}` and
Android support is not required, pass
`measureInWindow: false{:.key}`.

This non-default path is currently broken on Android due to an
upstream React Native measurement bug. See
[facebook/react-native#29712 (comment)](https://github.com/facebook/react-native/issues/29712#issuecomment-1086475698)
and
[floating-ui/floating-ui#2904](https://github.com/floating-ui/floating-ui/issues/2904).

## Anchoring

`useFloating(){:js}` only calculates the position **once** on
render, or when the reference/floating elements changed.
Depending on the context in which the floating element lives, you
may need to update its position in an Effect.

The Hook returns an `update(){:js}` function to update the
position at will:

```js
const {update} = useFloating();
```

## Refs

To access the elements, you can either access the refs:

```js
const {refs} = useFloating();

// Inside an Effect or event handler:
refs.reference.current;
refs.floating.current;
```

Or the elements directly:

```js
const {elements} = useFloating();

// During render, unlike the refs:
elements.reference;
elements.floating;
```

External elements can be synchronized like so, if they live
outside the component:

```js
function MyComponent({referenceEl, floatingEl}) {
  const {refs} = useFloating({
    elements: {
      reference: referenceEl,
      floating: floatingEl,
    },
  });
}
```

## Arrow

A plain `ref{:.const}` can be passed as the `element{:.key}`
value:

```jsx /arrowRef/1-2 {11}
import {useRef} from 'react';
import {useFloating, arrow} from '@floating-ui/react-native';

function App() {
  const arrowRef = useRef();
  const {
    refs,
    floatingStyles,
    middlewareData: {arrow: {x: arrowX, y: arrowY} = {}},
  } = useFloating({
    middleware: [arrow({element: arrowRef})],
  });

  // Pass the `arrowRef` to the element
}
```

## offsetParent

Pass this to the floating element's `offsetParent`, if required
for positioning:

<Notice gap="above">
  This nested `offsetParent` pattern is currently not reliable on
  Android due to upstream measurement behavior. For Android
  support, use a root-sibling portal layout instead.
</Notice>

```jsx /offsetParent/
import {View, Text, ScrollView} from 'react-native';
import {useFloating} from '@floating-ui/react-native';

function App() {
  const {refs, floatingStyles} = useFloating();

  return (
    <View>
      <ScrollView>
        <View ref={refs.setReference} collapsable={false}>
          <Text>Reference</Text>
        </View>
      </ScrollView>

      <View ref={refs.setOffsetParent} collapsable={false}>
        <View
          ref={refs.setFloating}
          collapsable={false}
          style={floatingStyles}
        >
          <Text>Floating</Text>
        </View>
      </View>
    </View>
  );
}
```
